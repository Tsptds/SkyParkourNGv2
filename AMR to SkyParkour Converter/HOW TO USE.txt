This is a python script & a batch file to convert AMR annotations to the new SkyParkour format. 

You need hkanno & HCT 2010.2 for annotating skyrim animations.

SkyParkour supports root motion-like movement, where you can export root motion data from the root motion export blender plugin
and then use this tool to convert AMR annotations to be useable by SkyParkour.
Just put your annotation txt files into _Annotations folder, run "Convert All AMR to SkyParkour" bat file and the txt files will be overwritten.

But this format also allows achieving decent movement with manual annotations and having some more control over them.

SkyParkour now doesn't rely on AMR nor Skyrim's animation driven movement system, instead
it uses the animation event & payload system of Skyrim to process this data, so it should be familiar to people
who already know how they work.


Animation events looks like this: 
	
	<timestamp> <animation event name>.<payload>

These anim events trigger certain stuff in the game, and have payloads for additional data.
<Timestamp> is the time when annotation triggers (for e.g 0.333334). The timestamps aren't in real seconds, but more like <timestamp> multiplied by a second.


The format of SkyParkour annotations:
-------------------------------
<Timestamp> SkyParkour_Move.x|y|z@s
-------------------------------
where:	
	<Timestamp> is the start time
	SkyParkour_Move is the animation event
	the part after the first dot (.) is the payload, that contains all the motion data

payload structure: (x|y|z@s) separated by | between axes and @ for time of flight.

	x is left/right
	y is back/forward
	z is down/up

(Negative values / Positive values)
These offsets are relative to the starting position of the animation, just like AMR.

and
	s is how much time player will take to get there.
	This means you don't need to put an "animmotion 0 0 0" equivalent inbetween to prevent early movement when manually annotating.


A very simple example on the annotation:

	0.500000 SkyParkour_Move.0|50|120@2

Which means on 0.5, start moving "no left right", "50 forward", "120 up" in "2" seconds. This will get you there at 2.500000 timestamp.


The s value + timestamp should ideally be shorter than the next move event timestamp, logically, so the previous movement can end.

An example annotation sequence converted from AMR:

	0.866667 SkyParkour_Move.0.0|11.0|35.0@0.033333
	0.900000 SkyParkour_Move.0.0|18.0|55.0@0.500000

This basically means, on 0.866667 timestamp, start going to x->0 y->11 z->35 in 0.033333 seconds.
Then on 0.9, start going to x->0 y->18 z->55 in 0.5 seconds.

As mentioned above, in case of too long s values, previous movement will cancel. This can result in the next movement being faster to catch up.

YOU DON'T NEED TO ADD ALL THOSE ZEROS AFTER x y z or s values, it's just how the exporter formats it.

Numbers are of type float so you can have something like 0.001234567890 though I see no point in such little movement.