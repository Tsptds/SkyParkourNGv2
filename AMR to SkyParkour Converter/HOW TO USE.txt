This is a python script & a batch file to convert AMR annotations to the new SkyParkour format. 

You need hkanno & HCT 2010.2 for annotating skyrim animations.

SkyParkour supports root motion-like movement, where you can export root motion data from the root motion export blender plugin
and then use this tool to convert AMR annotations to be useable by SkyParkour.
Just put your annotation txt files into _Annotations folder, run "Convert All AMR to SkyParkour" bat file and the txt files will be overwritten.
The tool will preserve SoundPlay annotations, but any other will be lost in the process.

This format also allows achieving decent movement with manual annotations and having some more control over them.

SkyParkour now doesn't rely on AMR nor Skyrim's animation driven movement system, instead
it uses the animation event & payload system of Skyrim to process this data, so it should be familiar to people
who already know how they work.


Animation events looks like this: 
	
	<timestamp> <animation event name>.<payload>

These anim events trigger certain stuff in the game, and have payloads for additional data.
<Timestamp> is the time when annotation triggers (for e.g 0.333334). The timestamps aren't in real seconds, but more like <timestamp> multiplied by a second.


There are 4 main anim events:
SkyParkour_Start
SkyParkour_Stop
SkyParkour_Move
SkyParkour_Recovery

> Start and Stop are fired automatically, you shouldn't add these to your animations.
> Move is the equivalent of AMR's animmotion
> Recovery is for having a skippable window for the animation, exits early if any of the 4-way movement input is received after this event.

The format of SkyParkour_Move annotation:
-------------------------------
<Timestamp> SkyParkour_Move.x|y|z@s
-------------------------------
where:	
	<Timestamp> is the start time
	SkyParkour_Move is the animation event
	the part after the first dot (.) is the payload, that contains all the motion data

payload structure: (x|y|z@s) separated by | between axes and @ for time of flight.

	x is left/right
	y is back/forward
	z is down/up

(Negative values / Positive values)
These offsets are relative to the starting position of the animation, just like AMR.

and
	s is how much time player will take to get there.
	This means you don't need to put an "animmotion 0 0 0" equivalent inbetween to prevent early movement when manually annotating.


A very simple example on the annotation:

	0.500000 SkyParkour_Move.0|50|120@2

Which means on 0.5, start moving "no left right", "50 forward", "120 up" in "2" seconds. This will get you there at 2.500000 timestamp.


The s value + timestamp should ideally be shorter than the next move event timestamp, logically, so the previous movement can end.

An example annotation sequence converted from AMR:

	0.866667 SkyParkour_Move.0.0|11.0|35.0@0.033333
	0.900000 SkyParkour_Move.0.0|18.0|55.0@0.500000

This basically means, on 0.866667 timestamp, start going to x->0 y->11 z->35 in 0.033333 seconds. (Arrives ar 0.9)
Then on 0.9, start going to x->0 y->18 z->55 in 0.5 seconds. (Arrives at 1.4)

As mentioned above, in case of too long s values, previous movement will cancel. This can result in the next movement being faster to catch up.

YOU DON'T NEED TO ADD ALL THOSE ZEROS AFTER x y z or s values, it's just how the exporter formats it.

Numbers are of float type so you can have something like 0.001234 though I see no point in such little movement.